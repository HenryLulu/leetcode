# 动态规划
## 思路
> 将问题分解为若干个重叠的单阶段子问题，后面阶段的子问题往往就是前面的母问题，通过各个子母问题间的关系，逐个求解并保存子问题解，最终获得原问题解。

## 什么样的问题适合用动态规划？
### 特征
动态规划最大的特点是描述子问题间的【依赖性】，具体说，可以用动态规划的问题特征：
* 最优子结构：通过对子问题的已知最优解的规划，可以得到母问题的最优解；后阶段母问题的最优解依赖前阶段子问题。
* 子问题重叠：子母问题的规划求最优解方式本质上一致，只是输入参数不同。
* 存在边界：在某种情况下，子问题求解不依赖于其他阶段，这就是依赖的终点
* 子问题相互独立
### 常见问题
最常见的动态规划用于解决以下问题：
* 最后一个母问题的值：通过动态规划，逐步从0规划到n，n阶段子问题的解就是我们要的解。比如：70:走n级台阶有多少种走法
* 最值：在动态规划过程中，求解每个阶段的最优解，并在其中选择最值。比如：53:找到数组中和最大的子数组

## 求解步骤
### 1 找子问题
其实就是【找规律】，问题的求解目标可以作为一个线索，关键是子问题间一定要有单向的依赖关系，举几个例子：
* 上前n级台阶有几种走法（依赖前n-1、n-2的解）
* 以第n位为结尾的最大和子数组（依赖n-1的解）

### 2 找状态转移方程
就是前面说的【依赖关系】，可以理解为一个纯函数：
* 输入：若干个依赖子问题的解、当前子问题输入
* 输出：当前子问题的解
比如：
* 爬到第n级的走法 = 爬到第n-1级走法（再走一节） + 爬到第n-2级走法（再走两节）
* 以当前元素为结尾的最大子序列和 = max（ 以前一元素结尾的最大子序列和 + 当前元素，当前元素 ）

### 3 找边界
即不需要依赖、部分依赖其他解的子问题解。常见的边界：
* 初始1-2位解：比如上0、1级台阶的方式 = 1
* 二维下坐标相同：比如 起index === 止index 时的子字符串是否为回文
* 二维下坐标遇0
边界通常有两种赋值方式：
* 循环计算前赋值：通常给一维数组这么做
* 循环内条件判断赋值：复杂的情况需要这么做

### 4 建立存储
在找到子问题后，我们需要存储子问题的解，通常为 1个（偶尔需要多个） 1-2 维数组，主要取决于子问题划分的方式。     

### 5 依赖方向、范围，计算母问题解
建立存储后，就可以给边界赋值，再按照依赖的方向，根据状态转移方程，计算子问题解。需要注意的是计算的方向和范围，特别是二维情况下：
* 方向不见得是0～n：比如m～n位子字符串是否回文，要依赖m+1～n-1，这里的m就是反向的
* 范围：还是m～n位子字符串是否回文，n是肯定大于等于m的，范围外的不需要遍历

### 6 得到最终解
全部循环计算完毕后，这个解就出来了，通常是：
* 存储中的某一位的解
* 存储中若干值的最解

## 程序模版
```
if (数据范围只有边界情况) return 边界值

// 建立存储
const cache = 一维/二维数组
// 赋值边界（需要的话）
cache[...] = 边界值
// 供更新的最解变量（需要的话）
let MAX = ...
// 循环求解，通常1～2层
for (let m...) {
    for (let n...) {
        // 赋值边界
        if (...) cache[m][n] = ...
        // 正常状态转移逻辑
        if (...) {
            cache[m][n] = ...cache[m+1][n-1]...
        } else if ...
    }
}

// 返回最终解
return cache[...][...] or MAX;
```