# 排序
## 快速排序

## 归并排序
### 基本原理
* 归并排序把集合不断等分，直至拆分为单个元素，比如：4213 --> 42|13 --> 4|2|1|3
* 在递归合并过程中，保持各子集单调：4|2|1|3 --> 24|13 --> 1234
* 由于每一次归并操作输入的两子集都是单调的，就可以从两子集的一端比较，生成新的单调子集
### 复杂度
时间复杂度：O(nlog(n))，不考虑递归栈，需要O(n)的辅助空间，但如果是链表，可以把辅助空间降至常数级
### 题目
* 148-链表排序

## 堆排序
维护一个大顶或小顶堆，重复执行：取堆顶 - 把堆尾补到堆顶 - 调整堆顶节点获得新堆顶 - 取堆顶，这样获得的数组就是顺序的。
### 堆的基本概念
* 堆就是一个完全二叉树
* 大顶堆的每个节点都是【节点本身/左子树/右子树】中最大的，小顶堆亦然
### 堆的表示
在JS中通常直接在待排序数组上维护一个堆，index=0就是堆顶，通过二叉树特性定位节点父子见的index关系
```
// 一个大顶堆
const heap = [ 16, 14, 10, 8, 7, 9, 3, 2, 4, 1 ];
// 节点关系
parentIndex = Math.floor((index - 1) / 2)
leftChildIndex = index * 2 + 1
rightCHildIndex = index * 2 + 2
// 更多见 ./common/heap.js
```
### 堆排序擅长做的事
对完整排序工作来说，堆排并不是最理想的，但堆排擅长维护一个集合的最值：
* 快速比较当前值是否比一个集合的最大值还大，进行替换，并能维持集合状态

比如：
* 347-出现频率最高的前k个元素：维持一个大小为k的小顶堆