# 二叉树
## js中的表示
### object
通常通过一个包含 val/left/right 属性的对象表示一个节点，通过 left/right 把节点连接成树。如：
```
const childNode = {
    val: 1,
    left: null,
    right: anotherNode
};
const root = {
    val: 1,
    left: childNode,
    right: anotherNode
};
```
### array
也可以用一个数组，表示序列化后的树，称为序列化（leetcode测试用例就是这么做的）
```
[1, 2, 3, null, null, 4, 5]
// 数组从根节点开始逐层遍历，null为空子节点的占位
```
### 序列化和反序列化
即在 object 和 array 互相转换，本来做了个刷题工具，没想到还真是道题（297），利用队列进行遍历。

## 解决树问题的常用思路
### 递归
#### 树的结构特点适合递归
树的结构很有特点，根节点有它的左右子树，左右子树又分别有左右子树。这就使很多树的问题可以这样思考：
* 对于根节点，我们想要的结果或操作（往往就是最终结果），是可以基于【根节点值、左子树结果、右子树结果/操作】得出的
* 对于左右子节点以及树中的其他节点，同样符合上面规律
* 可以一直递归下去，直到某种条件，或者达到叶子节点（这就是递归终点）

比如下面几题，通过以上思路思考递归方式：
* 各种遍历：以前序遍历为例，fn(n)表示对一个节点进行遍历操作，则fn中，先输出自身值，再fn(左节点)、fn(右节点)
* 104 - 树的最大深度：fn(n)表示求n为根的树最大深度，则fn = 1 + fn(左子树)/fn(右子树)中最大值
* 226 - 翻转二叉树：fn(n)表示翻转n为根的树，则fn中，左子树 = fn(右子树)；右子树 = fn(左子树)
* 617 - 合并二叉树：fn(a,b)返回两棵树的合并结果，则fn中，值 = ab值和，左/右子树 = fn(a左/右子树, b左/右子树)
* 101 - 判断树是否对称：fn(a,b)返回ab是否互为镜像，则fn要判断根节点值相同，且fn(a左子树, b右子树)、fn(a右子树, b左子树)都为true
* 236 - 给定两个节点的公共祖先（LCA）

#### 递归结合遍历、计数等操作
有些稍复杂的问题，仅像上面做一套递归是不够的，往往需要结合遍历、计数等其他操作。    
由于对同一子树的递归操作可能执行多次，甚至死循环，这里对子树计算结果的缓存就很必要，一般可以赋值到根节点属性上。    
比如：
* 437 - 找出路径和等于给定数值的路径总数
    * 递归思路：fn(n, l)表示从n节点出发向下路径和等于l的路径总数，则fn = 值 + fn(左节点, l-值) + fn(右节点, l-值)
    * 结合遍历：遍历所有节点，求每个节点出发向下路径和等于给定数值的路径总数
    * 结合计数：外层需要一个变量，累加遍历过程中每个节点返回结果
* 124 - 最大路径
* 114 - 把树展开为单链表

#### 多个递归函数组合
* 337 - 打家劫舍III

#### 不基于树结构的递归
有些树题目，比如输入不是一棵树，也可能通过递归实现，比如：
* 105 - 根据前序/中序遍历输出树结构

### 利用栈/队列
在树的题目中，对一个节点的处理可能产生更多待处理节点，栈/队列通常用来存储“待执行某个任务的节点”。选择栈/队列主要看想要的顺序。
#### 遍历
用递归遍历树很简单，但用栈/队列就显得有逼格。   
栈，先进后出，往往用在深度优先遍历中，比如
* 94 - 中序遍历
* 145 - 后序遍历

队列，先进先出，往往用在广度优先遍历，比如：
* 297 - 序列化和反序列化

至于单纯为了遍历，不管顺序，用什么都行




